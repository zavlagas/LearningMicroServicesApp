# LearningMicroServicesApp



#STEP BY STEP DETAILS

RESTful Web Services 

Step 01 - Initializing a RESTful Services Project with Spring Boot

Step 02 - Understanding the RESTful Services we would create in this course

Step 03 - Creating a Hello World Service

Step 04 - Enhancing the Hello World Service to return a Bean

Step 05 - Quick Review of Spring Boot Auto Configuration and Dispatcher Servlet - 	  What's happening in the background?

Step 06 - Enhancing the Hello World Service with a Path Variable

Step 07 - Creating User Bean and User Service

Step 08 - Implementing GET Methods for User Resource

Step 09 - Implementing POST Method to create User Resource

Step 10 - Enhancing POST Method to return correct HTTP Status Code and Location URI

Step 11 - Implementing Exception Handling - 404 Resource Not Found

Step 12 - Implementing Generic Exception Handling for all Resources

Step 13 - Exercise : User Post Resource and Exception Handling

Step 14 - Implementing DELETE Method to delete a User Resource

Step 15 - Implementing Validations for RESTful Services

Step 16 - Implementing HATEOAS for RESTful Services

Step 17 - Overview of Advanced RESTful Service Features

Step 18 - Internationalization for RESTful Services

Step 19 - Content Negotiation - Implementing Support for XML

Step 20 - Configuring Auto Generation of Swagger Documentation

Step 21 - Introduction to Swagger Documentation Format

Step 22 - Enhancing Swagger Documentation with Custom Annotations

Step 23 - Monitoring APIs with Spring Boot Actuator

Step 24 - Implementing Static Filtering for RESTful Service

Step 25 - Implementing Dynamic Filtering for RESTful Service

Step 26 - Versioning RESTful Services - Basic Approach with URIs

Step 27 - Versioning RESTful Services - Header and Content Negotiation Approaches

Step 28 - Implementing Basic Authentication with Spring Security

Step 29 - Overview of Connecting RESTful Service to JPA

Step 30 - Creating User Entity and some test data

Step 31 - Updating GET methods on User Resource to use JPA

Step 32 - Updating POST and DELETE methods on User Resource to use JPA

Step 33 - Creating Post Entity and Many to One Relationship with User Entity

Step 34 - Implementing a GET service to retrieve all Posts of a User

Step 35 - Implementing a POST service to create a Post for a User

Step 36 - Richardson Maturity Model

Step 37 - RESTful Services Best Practices

Microservices with Spring Cloud

Step 01 - Part 1 - Introduction to Limits Microservice and Spring Cloud Config Server

Step 01 - Part 2 - Setting up Limits Microservice

Step 02 - Creating a hard coded limits service

Step 03 - Enhance limits service to pick up configuration from application properties

Step 04 - Setting up Spring Cloud Config Server

Step 05 - Installing Git

Step 06 - Creating Local Git Repository

Step 07 - Connect Spring Cloud Config Server to Local Git Repository

Step 08 - Configuration for Multiple Environments in Git Repository

Step 09 - Connect Limits Service to Spring Cloud Config Server

Step 10 - Configuring Profiles for Limits Service

Step 11 - A review of Spring Cloud Config Server

Step 12 - Introduction to Currency Conversion and Currency Exchange Microservices

Step 13 - Setting up Currency Exchange Microservice

Step 14 - Create a simple hard coded currency exchange service

Step 15 - Setting up Dynamic Port in the the Response

Step 16 - Configure JPA and Initialized Data

Step 17 - Create a JPA Repository

Step 18 - Setting up Currency Conversion Microservice

Step 19 - Creating a service for currency conversion

Step 20 - Invoking Currency Exchange Microservice from Currency Conversion Microservice

Step 21 - Using Feign REST Client for Service Invocation

Step 22 - Setting up client side load balancing with Ribbon

Step 23 - Running client side load balancing with Ribbon

Step 24 - Understand the need for a Naming Server

Step 25 - Setting up Eureka Naming Server

Step 26 - Connecting Currency Conversion Microservice to Eureka

Step 27 - Connecting Currency Exchange Microservice to Eureka

Step 28 - Distributing calls using Eureka and Ribbon

Step 29 - A review of implementing Eureka, Ribbon and Feign

Step 30 - Introduction to API Gateways

Step 31 - Setting up Zuul API Gateway

Step 32 - Implementing Zuul Logging Filter

Step 33 - Executing a request through Zuul API Gateway

Step 34 - Setting up Zuul API Gateway between microservice invocations

Step 35 - Introduction to Distributed Tracing

Step 36 - Implementing Spring Cloud Sleuth

Step 37 - Introduction to Distributed Tracing with Zipkin

Step 38 - Installing Rabbit MQ

Step 39 - Setting up Distributed Tracing with Zipkin

Step 40 - Connecting microservices to Zipkin

Step 41 - Using Zipkin UI Dashboard to trace requests

Step 42 - Understanding the need for Spring Cloud Bus

Step 43 - Implementing Spring Cloud Bus

Step 44 - Fault Tolerance with Hystrix

Start Learning Now. Hit the Enroll Button!

What youâ€™ll learn

Develop and design RESTful web services with Spring Boot

Develop MICROSERVICES with Spring Boot and Spring Cloud

Orchestrate microservices with KUBERNETES

Create containers for microservices with DOCKER

IMPLEMENT Exception Handling, Validation, HATEOAS and filtering for RESTful Web Services.

Implement client side load balancing (Ribbon), Dynamic scaling(Eureka Naming Server) and an API Gateway (Zuul)

You will setup Centralized Microservices Configuration with Spring Cloud Config Server

You will learn to implement Distributed tracing for microservices with Spring Cloud Sleuth and Zipkin

You will implement Fault Tolerance for microservices with Hystrix

You will understand how to version your RESTful Web Services

You will understand how to monitor RESTful Services with Spring Boot Actuator

You will understand how to document RESTful Web Services with Swagger

You will understand the best practices in designing RESTful web services

Using Spring Cloud Bus to exchange messages about Configuration updates

Simplify communication with other Microservices using Feign REST Client